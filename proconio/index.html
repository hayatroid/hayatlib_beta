<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Easy IO library for competitive programming."><title>proconio - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="proconio" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0 (aedd173a2 2024-03-17)" data-channel="1.77.0" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-4c98445ec4002617.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../proconio/index.html">proconio</a><span class="version">0.4.5</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li><li><a href="#attributes">Attribute Macros</a></li></ul></section></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../proconio/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">proconio</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/proconio/lib.rs.html#8-1002">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Easy IO library for competitive programming.</p>
<p><code>proconio</code> provides an easy way to read values from stdin (or other source).  The main is
<code>input!</code> macro.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>The macro’s user interface is basically the same with <a href="https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8">tanakh’s input
macro</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proconio::input;

<span class="macro">input! </span>{
    n: u8,
    m: u32,
    l: i32,
}

<span class="comment">// now you can use n, m and l as variable.
</span><span class="macro">println!</span>(<span class="string">"{} {} {}"</span>, n, m, l);</code></pre></div>
<p>In above code, variables n, m and l are declared and stored values are read from stdin.</p>
<p>You can declare mutable variables like below:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proconio::input;

<span class="macro">input! </span>{
    n: u32,
    <span class="kw-2">mut </span>m: u32,
}

m += n; <span class="comment">// OK: m is mutable</span></code></pre></div>
<p>You can read an array or a matrix like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proconio::input;

<span class="macro">input! </span>{
    n: usize,
    m: usize,
    a: [[i32; n]; m] <span class="comment">// `a` is Vec&lt;Vec&lt;i32&gt;&gt;, (m, n)-matrix.
</span>}</code></pre></div>
<p>If the first input is the length of the array, you can omit the length.  This is the only way
to read jagged array (an array of arrays of which the member arrays can be of different sizes)
at once.  (Of course you can use <code>input!</code> multiple times in for-loop to read such an array
since <code>input!</code> can be used multiple times.)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proconio::input;

<span class="macro">input! </span>{
    n: usize,
    a: [[i32]; n],
}

<span class="comment">// if you enter "3  3 1 2 3  0  2 1 2" to the stdin, the result is as follows.
</span><span class="macro">assert_eq!</span>(
    a,
    <span class="macro">vec!</span>[
        <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],
        <span class="macro">vec!</span>[],
        <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>],
    ]
);</code></pre></div>
<p>Strings can be read as <code>Vec&lt;u8&gt;</code> or <code>Vec&lt;char&gt;</code>.  Use <code>Bytes</code> and <code>Chars</code> to do so:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proconio::input;
<span class="kw">use </span>proconio::marker::{Bytes, Chars};

<span class="macro">input! </span>{
    string: String, <span class="comment">// read as String
    </span>chars: Chars,   <span class="comment">// read as Vec&lt;char&gt;
    </span>bytes: Bytes,   <span class="comment">// read as Vec&lt;u8&gt;
</span>}

<span class="comment">// if you enter "string chars bytes" to the stdin, they are like this.
</span><span class="macro">assert_eq!</span>(string, <span class="string">"string"</span>);
<span class="macro">assert_eq!</span>(chars, [<span class="string">'c'</span>, <span class="string">'h'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>]);
<span class="macro">assert_eq!</span>(bytes, <span class="string">b"bytes"</span>);</code></pre></div>
<p>You can read tuples:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proconio::input;

<span class="macro">input! </span>{
    t: (i32, i32, i32, i32, i32),
}

<span class="comment">// if you enter "1 2 3 4 5" to the stdin, `t` is like this.
</span><span class="macro">assert_eq!</span>(t, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</code></pre></div>
<p>And you can freely combine these types.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proconio::input;

<span class="macro">input! </span>{
    n: usize,
    m: usize,
    t: [([u32; m], i32); n],
}</code></pre></div>
<p>You can use <code>input!</code> macro multiple times.  For the second time, <code>input!</code> macro reads rest of
input.  It works even if the first input stops at the middle of a line.  The subsequent reads
will be started at the rest of the line.  This may be helpful for problems where multiple
datasets are given once.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proconio::input;

<span class="macro">input! </span>{
    n: usize,
}

<span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..n {
    <span class="macro">input! </span>{
        m: usize,
        a: [i32; m],
    }
}</code></pre></div>
<p>In addition to <code>Chars</code> and <code>Bytes</code>, <code>Usize1</code> and <code>Isize1</code> are also special types.  They are
read as <code>usize</code> and <code>isize</code> respectively, but the read value is decremented.  It enables us to
automatically convert 1-indexed vertices numbers to 0-indexed array indices.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proconio::input;
<span class="kw">use </span>proconio::marker::Usize1;

<span class="macro">input! </span>{
    n: usize,
    edges: [(Usize1, Usize1); n],
}

<span class="comment">// if you enter "4   1 3   3 4   6 1   5 3", the decremented value is stored.
</span><span class="macro">assert_eq!</span>(edges[<span class="number">0</span>], (<span class="number">0</span>, <span class="number">2</span>));
<span class="macro">assert_eq!</span>(edges[<span class="number">1</span>], (<span class="number">2</span>, <span class="number">3</span>));
<span class="macro">assert_eq!</span>(edges[<span class="number">2</span>], (<span class="number">5</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(edges[<span class="number">3</span>], (<span class="number">4</span>, <span class="number">2</span>));</code></pre></div>
<p><code>Usize1</code> and <code>Isize1</code> doesn’t hold actual value, so you cannot have value of the type.  Thus,
they are only useful inside <code>input!</code> or <code>#[derive_readable]</code>.  You can think the reason these
types exist is to tell “how to read the value”.  This how-to can be defined through <code>Readable</code>
trait.  This trait doesn’t require the output type to be the same with the implementor.
<code>Usize1</code> is implementing <code>Readable</code> trait, and there the type of read value is defined as
<code>usize</code>.  You can implement <code>Readable</code> for your own type to read values in customized way.</p>
<p>Finally, you can make your own types <code>Readable</code> using <code>#[derive_readable]</code> attribute.  Types
used in the struct are automatically translated to their output types, so a member declared as
<code>Usize1</code> has type <code>usize</code> as real struct.</p>
<p><strong>Note:</strong> Using <code>#[derive_readable]</code> requires <code>derive</code> feature enabled.  To do so, open your
Cargo.toml and modify the line of proconio from:</p>
<div class="example-wrap"><pre class="language-toml"><code>proconio = &quot;=(version)&quot;
</code></pre></div>
<p>to:</p>
<div class="example-wrap"><pre class="language-toml"><code>proconio = { version = &quot;=(version)&quot;, features = [&quot;derive&quot;] }
</code></pre></div>
<p>Example of <code>#[derive_readable]</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proconio::input;
<span class="kw">use </span>proconio::derive_readable;

<span class="comment">// Unit struct can derive readable.  This generates a no-op for the reading.  Not ignoring
// the read value, but simply skip reading process.  You cannot use it to discard the input.
</span><span class="attr">#[derive_readable]
#[derive(PartialEq, Debug)]
</span><span class="kw">struct </span>Weight;

<span class="attr">#[derive_readable]
#[derive(PartialEq, Debug)]
</span><span class="kw">struct </span>Cost(i32);

<span class="attr">#[derive_readable]
#[derive(Debug)]
</span><span class="kw">struct </span>Edge {
    from: usize,
    to: proconio::marker::Usize1, <span class="comment">// The real Edge::to has type usize.
    </span>weight: Weight,
    cost: Cost,
}

<span class="kw">fn </span>main() {
    <span class="macro">input! </span>{
        edge: Edge,
    }

    <span class="comment">// if you enter "12 32 35" to the stdin, the values are as follows.
    </span><span class="macro">assert_eq!</span>(edge.from, <span class="number">12</span>);
    <span class="macro">assert_eq!</span>(edge.to, <span class="number">31</span>);
    <span class="macro">assert_eq!</span>(edge.weight, Weight);
    <span class="macro">assert_eq!</span>(edge.cost, Cost(<span class="number">35</span>));
}</code></pre></div>
<h2 id="fastout"><a class="doc-anchor" href="#fastout">§</a><code>#[fastout]</code></h2>
<p>If you import <code>proconio::fastout</code>, you can use <code>#[fastout]</code> attribute.  Adding this attribute
to your <code>main()</code>, your <code>print!</code> and <code>println!</code> become faster.</p>
<p><strong>Note:</strong> Using <code>#[proconio::fastout]</code> requires <code>derive</code> feature enabled.  To do so, open your
Cargo.toml and modify the line of proconio from:</p>
<div class="example-wrap"><pre class="language-toml"><code>proconio = &quot;=(version)&quot;
</code></pre></div>
<p>to:</p>
<div class="example-wrap"><pre class="language-toml"><code>proconio = { version = &quot;=(version)&quot;, features = [&quot;derive&quot;] }
</code></pre></div>
<p>Example of <code>#[fastout]</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proconio::fastout;

<span class="attr">#[fastout]
</span><span class="kw">fn </span>main() {
    <span class="macro">print!</span>(<span class="string">"{}{}, "</span>, <span class="string">'h'</span>, <span class="string">"ello"</span>); <span class="comment">// "hello"       (no newline)
    </span><span class="macro">println!</span>(<span class="string">"{}!"</span>, <span class="string">"world"</span>);      <span class="comment">// "world!\n"
    </span><span class="macro">println!</span>(<span class="string">"{}"</span>, <span class="number">123456789</span>);     <span class="comment">// "123456789\n"
</span>}</code></pre></div>
<h3 id="closures-having-print-or-println-in-fastout-function"><a class="doc-anchor" href="#closures-having-print-or-println-in-fastout-function">§</a>Closures having <code>print!</code> or <code>println!</code> in <code>#[fastout]</code> function</h3>
<p>You cannot create a closure containing <code>print!</code> or <code>println!</code> in <code>#[fastout]</code> function.  This
is because the closure becomes thread-unsafe since the closure refers the unlocked stdout
introduced by <code>#[fastout]</code> attribute.  If this were not prohibited, an invalid usage of such a
closure would produce a very complex error messages.  For example, <code>std::thread::spawn()</code>,
which requires its argument closure to be thread-safe, causes a confusing error.</p>
<p>Yes, it is too conservative to make all of such closures compilation error because it is
actually no problem to use such a closure only inside a single thread.  This is related to a
limitation in <code>#[fastout]</code> implementation.</p>
<p>For more technical details, see documentation for <code>#[fastout]</code> in <code>proconio-derive</code>.</p>
<h4 id="how-to-resolve-this-error"><a class="doc-anchor" href="#how-to-resolve-this-error">§</a>How to resolve this error</h4>
<p>Consider you want to run this code:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proconio::fastout;

<span class="attr">#[fastout]
</span><span class="kw">fn </span>main() {
    <span class="kw">let </span>thread = std::thread::spawn(|| {
        <span class="kw">let </span>x = <span class="number">3</span>;
        <span class="kw">let </span>y = x * x;
        <span class="macro">println!</span>(<span class="string">"{}"</span>, y);
    });

    thread.join().unwrap();
}</code></pre></div>
<p>You will get an error like below.</p>
<div class="example-wrap"><pre class="language-text"><code>error: Closures in a #[fastout] function cannot contain `print!` or `println!` macro

note: If you want to run your entire logic in a thread having extended size of stack, you can
define a new function instead.  See documentation (https://.....) for more details.

note: This is because if you use this closure with `std::thread::spawn()` or any other
functions requiring `Send` for an argument closure, the compiler emits an error about thread
unsafety for our internal implementations.  If you are using the closure just in a single
thread, it&#39;s actually no problem, but we cannot check the trait bounds at the macro-expansion
time.  So for now, all closures having `print!` or `println!` is prohibited regardless of the
`Send` requirements.
 --&gt; src/test.rs:10:9
   |
10 |         println!(&quot;{}&quot;, y);
   |         ^^^^^^^
</code></pre></div>
<p>If your <code>print!</code> is relying on the calculation in the thread, you can instead return the result
from the thread.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proconio::fastout;

<span class="attr">#[fastout]
</span><span class="kw">fn </span>main() {
    <span class="kw">let </span>thread = std::thread::spawn(|| {
        <span class="kw">let </span>x = <span class="number">3</span>;
        x * x
    });

    <span class="kw">let </span>y = thread.join().unwrap();
    <span class="macro">println!</span>(<span class="string">"{}"</span>, y);
}</code></pre></div>
<p>If you are doing so complex job that it’s too difficult to returning the results from your
closure…</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proconio::fastout;


<span class="attr">#[fastout]
</span><span class="kw">fn </span>main() {
    <span class="kw">let </span>context = <span class="string">"some context"</span>.to_string();
    <span class="kw">let </span>thread = std::thread::spawn(<span class="kw">move </span>|| {
        <span class="comment">// Use many println! and the order is very important
        // It's possible to aggregate the result and print it later, but it's not easy to read
        // and seems ugly.
        </span><span class="macro">println!</span>(<span class="string">"this is header."</span>);
        <span class="kw">for </span>(i, item) <span class="kw">in </span>some_function(context).enumerate() {
            <span class="macro">print!</span>(<span class="string">"Item #{}: "</span>, i);
            <span class="macro">print!</span>(<span class="string">"{}"</span>, some_proc(<span class="kw-2">&amp;</span>item));
            <span class="macro">println!</span>(<span class="string">"({})"</span>, item);
        }
    });

    thread.join().unwrap();
}</code></pre></div>
<p>…you can use a function instead.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>proconio::fastout;


<span class="comment">// You can add #[fastout] here
</span><span class="attr">#[fastout]
</span><span class="kw">fn </span>process(context: String) {
    <span class="comment">// It's completely OK since this #[fastout] is a thing inside `process()`
    </span><span class="macro">println!</span>(<span class="string">"this is header."</span>);
    <span class="kw">for </span>(i, item) <span class="kw">in </span>some_function(context).enumerate() {
        <span class="macro">print!</span>(<span class="string">"Item #{}: "</span>, i);
        <span class="macro">print!</span>(<span class="string">"{}"</span>, some_proc(<span class="kw-2">&amp;</span>item));
        <span class="macro">println!</span>(<span class="string">"({})"</span>, item);
    }
}

<span class="comment">// You must not add #[fastout] here!  It causes deadlock.
// #[fastout]
</span><span class="kw">fn </span>main() {
    <span class="kw">let </span>context = <span class="string">"some context"</span>.to_string();
    <span class="kw">let </span>thread = std::thread::spawn(<span class="kw">move </span>|| process(context));
    thread.join().unwrap();
}</code></pre></div>
<p><strong>Important Note:</strong> If you <em>spawn a new thread</em> which runs another function annotated with
<code>#[fastout]</code>, you must not add <code>#[fastout]</code> to the caller.  If you add <code>#[fastout]</code> in caller
too, then the caller has the lock for the stdout, and so callee cannot acquire the lock forever
— deadlock.  This is not the case when the caller and callee is executed in the same thread,
since the lock of stdout is reentrant.  We cannot warn about this kind of deadlock since we
don’t know annotations attached to the function to be called.  (In the above example, we can’t
know whether the function <code>process()</code> has <code>#[fastout]</code> attribute or not.)</p>
<p>If your code is so complex that you cannot avoid deadlock, you should give up using
<code>#[fastout]</code> and simply use <code>println!</code> or manually handle your stdout in usual Rust way.</p>
<h3 id="issues-of-printing-order"><a class="doc-anchor" href="#issues-of-printing-order">§</a>Issues of printing order</h3>
<p><code>#[fastout]</code> enables buffering to stdout, so if you print something in other functions between
two prints in main, the order of printing may differ.  In other words, the below example</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>foo() { <span class="macro">println!</span>(<span class="string">"between"</span>); }
<span class="attr">#[fastout]
</span><span class="kw">fn </span>main() {
    <span class="macro">println!</span>(<span class="string">"hello"</span>);
    foo();
    <span class="macro">println!</span>(<span class="string">"world"</span>);
}</code></pre></div>
<p><em>likely</em> prints like</p>
<div class="example-wrap"><pre class="language-text"><code>between
hello
world
</code></pre></div>
<p>If you don’t like this behavior, you can remove #<a href="attr.fastout.html" title="attr proconio::fastout">fastout</a> from your <code>main()</code>.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="marker/index.html" title="mod proconio::marker">marker</a></div><div class="desc docblock-short">Declares special marker types.</div></li><li><div class="item-name"><a class="mod" href="source/index.html" title="mod proconio::source">source</a></div><div class="desc docblock-short">Defines whitespace-splitted token stream wrapping actual stream like stdin.</div></li></ul><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.input.html" title="macro proconio::input">input</a></div><div class="desc docblock-short">read input from stdin.</div></li><li><div class="item-name"><a class="macro" href="macro.input_interactive.html" title="macro proconio::input_interactive">input_interactive</a></div><div class="desc docblock-short">read input from stdin interactively.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.StdinSource.html" title="enum proconio::StdinSource">StdinSource</a></div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.is_stdin_empty.html" title="fn proconio::is_stdin_empty">is_stdin_empty</a></div><div class="desc docblock-short">Checks if some of tokens are left on stdin.</div></li></ul><h2 id="attributes" class="section-header">Attribute Macros<a href="#attributes" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="attr" href="attr.derive_readable.html" title="attr proconio::derive_readable">derive_readable</a></div><div class="desc docblock-short">Derives <code>Readable</code> for your own type.</div></li><li><div class="item-name"><a class="attr" href="attr.fastout.html" title="attr proconio::fastout">fastout</a></div><div class="desc docblock-short">Enables buffering for stdout.</div></li></ul></section></div></main></body></html>